; test-v.1.0.x ini 文件解析测试
; Joshua Conero
; 2017年10月28日 星期六



'''
    计算分析模型 - 基枝分析模型
    文档行遍历(数据处理 交由 -> BBA 管理)



    ValueKey
    test = {
        terrr
        tets
        loogg
        ddee
        dddee
    }

    ; 优化模型 - 2017年11月3日 星期五 分析与设计
    BRCIdx = -1 / >-1       键值索引，
    BRCKey = 键值对应的 map 的 key值
    mLString = string/""   多行数组值，
    mLValue = interface{}  多行抽象值
    BranchRunningKeys => []string{}     // BranchRunning 孪生匹配键值
    BranchRunning => [
        [string] = {
            type = MAP/ARRAY/BOTH      ; 类型 map/array/both
            onlysa = bool         ; 仅仅是 string-array， (type = ARRAY)

            isInit = bool         ; 初始化标记
            ; value = []interface{} / map[string]interface{} 遗弃，使用两者共同代替
            array = []interface{}
            map   = map[string]interface{}
        }
    ]
'''
'''
    多行注释实现
    读取示例
'''

author = Joshua Conero
date = 2017年10月28日 星期六

; 转移字符测试
format = key1 \= value1
; 标点符号判断
format2 = "key1 \= value1; 双引号"

; 数组格式
array  = 1, 8, 9, 10
array2 = {1, 8, 9, 10}
array3 = {
    ; map = 在开头时可能会被认为是 map 乐行数据
    1
    8,
    9,
    10
    ; test = 数组内存在 map 类型/复杂类型， 意味着遍历任何数组初始化时都必须为 []interface\{\} 类型, 实际上这种类型很少
    '''
    ; 复杂array， array 内包含 k-v
    ; 2017年11月2日 星期四
    test = {
        4,
        87,
        gool = {
            ***
        }
    }
    => json
    {
        "array3": [
            {
                "map": "8855555"
            },
            1,
            8,
            9,
            10,
            {
                "test": "8855555"
            }
        ]
    }

    '''

}

; 转移符号的数组
strqueue = yetsss, 带\, 符号, 格式符号: \{键 \= 值\}
 
; 单行多重字符测试
single_mo = { key = { key2 = { key3 = { key4 = { key5 = { key6 = value6 }}}}}}

singlemap = {
    t1 = v1
    t2 = 单 map 解析 (二级处理)
    t3 = t3
    t4 = end
}


; 多行字符串示例
mlstring1 = "
    多行字符串解析处理
    Joshua Conero
    Version v1.0.5
    2017年11月4日 星期六
"
mlstring2 = "多行字符串
    1. Emma
    2. Lina
    3. Sia
"
mlstring3 = '多行字符串
    1. Emma
    2. Lina
    3. Sia
'


; '''
ms_map = {
    mlstring1 = "
        多行字符串解析处理
        Joshua Conero
        Version v1.0.5
        2017年11月4日 星期六
    "
    mlstring2 = "多行字符串
        1. Emma
        2. Lina
        3. Sia
    "
    ; '''
    mlarray = {
        '
            ~~ mlarray 1            
            1. Emma
            2. Lina
            3. Sia
        ',
        "
            ~~ mlarray 2       
            1. Emma
            2. Lina
            3. Sia
        ",
        '
            ~~ mlarray 3
            1. Emma
            2. Lina
            3. Sia
        ',
        "
            ~~ mlarray 4
            1. Emma
            2. Lina
            3. Sia
        ",
    }
    ; '''
}
; '''


'''
    无   test    date    test
    -1   0       1       1

'''
; 多重字符解析
test = {
    second = 二级子集
    date = {
        test = 多级ini文件解析
        date = date 为 map 类型
    }
    remark = 多次，复合类型
    test = {
        second = 同类型可值相同
    }
    ; '''
    smap = {
        {
            name = map 类型数组
            test = 2017年11月3日 星期五
        }{
            name = map 类型数组
            test = 2017年11月3日 星期五
            TEST = {
                TEST = {
                    TEST = {
                        TEST = {
                            TEST = {
                                TEST = {
                                    TEST = {
                                        TEST = {
                                            TEST = {
                                                TEST = 十级子复杂类型， 2017年11月3日 星期五
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }{
            name = map 类型数组
            test = 2017年11月3日 星期五
        }
    }
    ; '''
}

; 表格格式测试
tablename = {
    header = {c1, c2, c3, c4}
    '''
    data = {
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
        {v1, v2, v3, v4},
    }
    '''
}

end = rong test file